<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-09-12T10:22:21+01:00</updated><id>/feed.xml</id><title type="html">Donal Mee</title><subtitle>Notes on software and other things.</subtitle><entry><title type="html">Static site generators</title><link href="/2020/09/11/static-site-generators.html" rel="alternate" type="text/html" title="Static site generators" /><published>2020-09-11T11:24:00+01:00</published><updated>2020-09-11T11:24:00+01:00</updated><id>/2020/09/11/static-site-generators</id><content type="html" xml:base="/2020/09/11/static-site-generators.html">&lt;h1 class=&quot;no_toc&quot; id=&quot;static-site-generators&quot;&gt;Static Site Generators&lt;/h1&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#desirable-prior-experience&quot; id=&quot;markdown-toc-desirable-prior-experience&quot;&gt;Desirable prior experience&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#advantages-of-static-site-generation&quot; id=&quot;markdown-toc-advantages-of-static-site-generation&quot;&gt;Advantages of static site generation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#when-arent-static-sites-enough&quot; id=&quot;markdown-toc-when-arent-static-sites-enough&quot;&gt;When aren’t static sites enough?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resources&quot; id=&quot;markdown-toc-resources&quot;&gt;Resources&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#references&quot; id=&quot;markdown-toc-references&quot;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m inclined to think that almost everyone should use a static-site generator. A static-site generator takes something like markdown and spits out something like HTML. For most websites, a static-site generator is probably the optimum solution. There are some significant advantages to static site generators over dynamically produced sites.&lt;/p&gt;

&lt;p&gt;Static site generators are less complicated for beginners to understand. You write your website using something like &lt;a href=&quot;markdown-guide&quot;&gt;markdown&lt;/a&gt;. Then you install something like &lt;a href=&quot;python-org&quot;&gt;python&lt;/a&gt; and some libraries like &lt;a href=&quot;sphinx-home&quot;&gt;sphinx&lt;/a&gt;. You run sphinx over the markdown and out pops a full website. (This is how this website is created.) To make your website publically available, you can then use something like &lt;a href=&quot;github-pages&quot;&gt;Github Pages&lt;/a&gt; that will serve the website on your domain. (Again, this is how this site works.) This is less complicated, I think, than setting up a web-site server and then getting it to produce web-pages. The workflows are really quite nice and it isn’t too difficult to get comfortable with it.&lt;/p&gt;

&lt;h2 id=&quot;desirable-prior-experience&quot;&gt;Desirable prior experience&lt;/h2&gt;

&lt;p&gt;It would be helpful, if you want to build a static-site, to have some experience with the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A basic understanding HTML and CSS and maybe JavaScript. After-all, these are the things the static generator will be creating. So it’s helpful to understand what you are producing.&lt;/li&gt;
  &lt;li&gt;A basic understanding of a programming language. I imagine decent static site generators are almost certainly available in all the major programming languages. Given the ubiquity of the web, most languages will be able to generate static websites. Off the top of my head, I have used generators written in python and ruby generators, and I have probably used generators in other languages as well. And within those two languages, there are quite a few generators to chose from. So which language you’ve played around with, isn’t important. Just find a generator built in the language you’ve tried.&lt;/li&gt;
  &lt;li&gt;An understanding of how to use git or some version-control software. Saving the state of your website is super useful and using some version control software will make that go smoothly. It’s also how we deploy websites to Github Pages.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;advantages-of-static-site-generation&quot;&gt;Advantages of static site generation&lt;/h2&gt;

&lt;p&gt;Generally, I think static sites have the ‘simplicity’ advantage over dynamically generated sites. This simplicity helps a lot.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The content of the site can be kept in version control&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Static sites can be contained entirely within a version control system like git. This means that it’s very easy to evolve and change your website, and you have the peace-of-mind that your website’s content is backed up within git.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Speed, security, cost and maintanence&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Static sites tend to have the benefit of speed and security and cost and maintanence.&lt;/p&gt;

&lt;p&gt;The first, speed. Static websites are (generally) faster than dynamic websites. Because every single page is already generated, the webserver only needs to find out which page the user is requesting and then can fling it back at them without thinking. Whereas, a dynamic site will require some server-side processing.&lt;/p&gt;

&lt;p&gt;Second, because the server does almost &lt;em&gt;no&lt;/em&gt; processing of the request, hosting the site poses limited security risks. A user can’t really do anything except request a page, and that doesn’t result in any ‘leaky’ or problematic processing on the server. What kind of security risk is there? The request is just sending back fixed responses. Are there security risks? Yes, there can be. But the attack surface is greatly reduced.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cost and maintanence&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Third, static sites are so simple you can use something like Github Pages to serve your website. This means you don’t have to run or maintain the webserver. Thus your cost to host is zero and you pass almost all maintanence and security considerations onto the hoster - Github. And Github Pages even makes it &lt;em&gt;free&lt;/em&gt; for you to host your website with them. (Provided the website’s repository is public. I think you might have to pay a small fee if you want to keep the repository private.). It’s that easy for them to do it.&lt;/p&gt;

&lt;p&gt;Because your pages are static, the hosting company can put the website behind a content-delivery-network that uses caching and other tricks to allow your website to handle huge volumes of page requests super-fast.&lt;/p&gt;

&lt;p&gt;In addition, if Github Pages were ever to decide that it did not want to host your website (I believe that is &lt;em&gt;unlikely&lt;/em&gt;), there are lots of free providers out there. For example, I could host my site on &lt;a href=&quot;read-the-docs-home&quot;&gt;Read the Docs&lt;/a&gt; just as easily. As they basically use the same build process I use (git -&amp;gt; python -&amp;gt; sphinx). Or if I wanted too, I could easily run my own webserver like nginx to host the site. Or whatever other webserver you might want to use.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit and publish from almost anywhere&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To edit your website, all you need is a computer with the git repository on it (presuming git is your version control system). You simply clone the repository onto your laptop and fetch the latest version. Then you can use a text-editor like &lt;a href=&quot;sublime-home&quot;&gt;Sublime&lt;/a&gt; to make your changes. And then, you can build your website using your generator. Finally, to deploy the site, you just comit your changes and push to the server. I personally find that quite a lot easier than using a web-gui like the type you find on WordPress sites. All you really need to deploy is an internet connection. And because you push the data once your happy the site is ready, you don’t need internet when your editing. And you only need a small amount of internet to push the site to the server, once your ready.&lt;/p&gt;

&lt;h2 id=&quot;when-arent-static-sites-enough&quot;&gt;When aren’t static sites enough?&lt;/h2&gt;

&lt;p&gt;In some ways, I think static generation should be the defacto way for reasonably-technical users to create websites. They require so little to get working and out-perform the alteratives, that there are only some cases when you’d consider an alternative. The most important is if you want to create a dynamic site that does something like process information that is specific to each user visiting the site (like a shopping website or a social media website). If your website needs to know and do things for every user, then making the site dynamic becomes more important and you might begin to consider what is appropriate to do on your webserver’s backend. However, even in those circumstances, you’ll often have a large amount of static content. And so you may even be able to use a static site generator combined with a dynamic backend. I haven’t experimented with that because I haven’t needed to, but I don’t see why it wouldn’t work very well.&lt;/p&gt;

&lt;h2 id=&quot;resources&quot;&gt;Resources&lt;/h2&gt;

&lt;p&gt;As typical for the Hitchhikers guide to Python, they have a pretty great section on documentation that includes a lot of information about how to use static-generators to document your code. https://docs.python-guide.org/writing/documentation/&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.markdownguide.org/&quot;&gt;markdown-guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.python.org/&quot;&gt;python-org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sphinx-doc.org/en/master/&quot;&gt;sphinx-home&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;github-pages&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;sublime-home&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://readthedocs.org/&quot;&gt;read-the-docs-home&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Static Site Generators Desirable prior experience Advantages of static site generation When aren’t static sites enough? Resources References I’m inclined to think that almost everyone should use a static-site generator. A static-site generator takes something like markdown and spits out something like HTML. For most websites, a static-site generator is probably the optimum solution. There are some significant advantages to static site generators over dynamically produced sites. Static site generators are less complicated for beginners to understand. You write your website using something like markdown. Then you install something like python and some libraries like sphinx. You run sphinx over the markdown and out pops a full website. (This is how this website is created.) To make your website publically available, you can then use something like Github Pages that will serve the website on your domain. (Again, this is how this site works.) This is less complicated, I think, than setting up a web-site server and then getting it to produce web-pages. The workflows are really quite nice and it isn’t too difficult to get comfortable with it. Desirable prior experience It would be helpful, if you want to build a static-site, to have some experience with the following: A basic understanding HTML and CSS and maybe JavaScript. After-all, these are the things the static generator will be creating. So it’s helpful to understand what you are producing. A basic understanding of a programming language. I imagine decent static site generators are almost certainly available in all the major programming languages. Given the ubiquity of the web, most languages will be able to generate static websites. Off the top of my head, I have used generators written in python and ruby generators, and I have probably used generators in other languages as well. And within those two languages, there are quite a few generators to chose from. So which language you’ve played around with, isn’t important. Just find a generator built in the language you’ve tried. An understanding of how to use git or some version-control software. Saving the state of your website is super useful and using some version control software will make that go smoothly. It’s also how we deploy websites to Github Pages. Advantages of static site generation Generally, I think static sites have the ‘simplicity’ advantage over dynamically generated sites. This simplicity helps a lot. The content of the site can be kept in version control Static sites can be contained entirely within a version control system like git. This means that it’s very easy to evolve and change your website, and you have the peace-of-mind that your website’s content is backed up within git. Speed, security, cost and maintanence Static sites tend to have the benefit of speed and security and cost and maintanence. The first, speed. Static websites are (generally) faster than dynamic websites. Because every single page is already generated, the webserver only needs to find out which page the user is requesting and then can fling it back at them without thinking. Whereas, a dynamic site will require some server-side processing. Second, because the server does almost no processing of the request, hosting the site poses limited security risks. A user can’t really do anything except request a page, and that doesn’t result in any ‘leaky’ or problematic processing on the server. What kind of security risk is there? The request is just sending back fixed responses. Are there security risks? Yes, there can be. But the attack surface is greatly reduced. Cost and maintanence Third, static sites are so simple you can use something like Github Pages to serve your website. This means you don’t have to run or maintain the webserver. Thus your cost to host is zero and you pass almost all maintanence and security considerations onto the hoster - Github. And Github Pages even makes it free for you to host your website with them. (Provided the website’s repository is public. I think you might have to pay a small fee if you want to keep the repository private.). It’s that easy for them to do it. Because your pages are static, the hosting company can put the website behind a content-delivery-network that uses caching and other tricks to allow your website to handle huge volumes of page requests super-fast. In addition, if Github Pages were ever to decide that it did not want to host your website (I believe that is unlikely), there are lots of free providers out there. For example, I could host my site on Read the Docs just as easily. As they basically use the same build process I use (git -&amp;gt; python -&amp;gt; sphinx). Or if I wanted too, I could easily run my own webserver like nginx to host the site. Or whatever other webserver you might want to use. Edit and publish from almost anywhere To edit your website, all you need is a computer with the git repository on it (presuming git is your version control system). You simply clone the repository onto your laptop and fetch the latest version. Then you can use a text-editor like Sublime to make your changes. And then, you can build your website using your generator. Finally, to deploy the site, you just comit your changes and push to the server. I personally find that quite a lot easier than using a web-gui like the type you find on WordPress sites. All you really need to deploy is an internet connection. And because you push the data once your happy the site is ready, you don’t need internet when your editing. And you only need a small amount of internet to push the site to the server, once your ready. When aren’t static sites enough? In some ways, I think static generation should be the defacto way for reasonably-technical users to create websites. They require so little to get working and out-perform the alteratives, that there are only some cases when you’d consider an alternative. The most important is if you want to create a dynamic site that does something like process information that is specific to each user visiting the site (like a shopping website or a social media website). If your website needs to know and do things for every user, then making the site dynamic becomes more important and you might begin to consider what is appropriate to do on your webserver’s backend. However, even in those circumstances, you’ll often have a large amount of static content. And so you may even be able to use a static site generator combined with a dynamic backend. I haven’t experimented with that because I haven’t needed to, but I don’t see why it wouldn’t work very well. Resources As typical for the Hitchhikers guide to Python, they have a pretty great section on documentation that includes a lot of information about how to use static-generators to document your code. https://docs.python-guide.org/writing/documentation/ References markdown-guide python-org sphinx-home github-pages sublime-home read-the-docs-home</summary></entry><entry><title type="html">Running a Git client-side pre-commit hook</title><link href="/2020/08/25/Pre-commit-git-hooks.html" rel="alternate" type="text/html" title="Running a Git client-side pre-commit hook" /><published>2020-08-25T07:00:00+01:00</published><updated>2020-08-25T07:00:00+01:00</updated><id>/2020/08/25/Pre-commit-git-hooks</id><content type="html" xml:base="/2020/08/25/Pre-commit-git-hooks.html">&lt;h1 id=&quot;how-to-run-a-test-before-every-git-commit&quot;&gt;How to run a test before every git commit&lt;/h1&gt;

&lt;p&gt;Summary:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Configure a git client-side &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare-commit-msg&lt;/code&gt; hook to run a test before every commit.&lt;/li&gt;
  &lt;li&gt;Setup &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.gitconfig&lt;/code&gt; file in the root of the repository and set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hooksPath = git_hooks&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Write a bash script inside &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git_hooks\prepare-commit-msg&lt;/code&gt; that runs your tests before a commit.&lt;/li&gt;
  &lt;li&gt;You can distribute the hooks in the repository but you &lt;strong&gt;cannot&lt;/strong&gt; enforce the (client-side) hooks use.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ddmee/git-hooks/tree/master/git_hooks&quot;&gt;example-code&lt;/a&gt; is available.&lt;/p&gt;

&lt;h2 id=&quot;running-a-git-client-side-pre-commit-hook&quot;&gt;Running a Git client-side pre-commit hook&lt;/h2&gt;

&lt;p&gt;Git hooks allow you to hook into the pull/commit/push process that git is built around. A hook is useful if you want to extend or customise the behaviour of your repository. There are two types of hooks, server-side commits and client-side commits. Server-side hooks live on a git server (i.e. somewhere people push to, like a centralised github server). Client-side hooks live on each individual contributors development machine.&lt;/p&gt;

&lt;p&gt;Server-side hooks are a way you can enforce certain behaviours on the server. I’m not going to talk about them here. Instead, I’m going to look at client-side hooks.&lt;/p&gt;

&lt;p&gt;Have you ever wanted to run some sort of check on the code you are about to commit? You can do this with a client-side hook. However, one issue with client-side hooks is that they are not versioned in the git repository. I used to think this prohibited ‘distrbution’ of the client-side git hooks with the repository. Which sucks. Because, lets say you introduce a new developer to your repo, perhaps you’d like them to run the same checks as you do, they way you do. Traditionally, that’s not been possible with client-side hooks. However, there is a way (since git version 2.9). You need to configure the ‘hooksPath’.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-client-side-hooks-so-everyone-runs-them&quot;&gt;Setting up client-side hooks so everyone runs them&lt;/h2&gt;

&lt;p&gt;In the root of your git repo, add the file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.gitconfig&lt;/code&gt; with this content:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[core]
    hooksPath = git_hooks
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When the repository is cloned, it points git to run hooks from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git_hooks&lt;/code&gt; subdirectory. Normally, git hooks are stored in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git/hooks&lt;/code&gt;, and that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git/&lt;/code&gt; directory is not stored in the version-control (thus prohibiting distribution with the source-code). But with the (new as of git 2.9) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hooksPath&lt;/code&gt; option, you can instead point to another directory in the repository that does store the hooks.&lt;/p&gt;

&lt;p&gt;However, git will &lt;em&gt;not&lt;/em&gt; use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.gitconfig&lt;/code&gt; automatically. Apparently it’s a security issue (see &lt;a href=&quot;https://stackoverflow.com/questions/18329621/how-to-store-a-git-config-as-part-of-the-repository&quot;&gt;stackoverflow-store-gitconfig&lt;/a&gt;). Instead, the user who has cloned the repository must explicitly tell git to use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.gitconfig&lt;/code&gt;.  They only need to run this command once. I have it as a &lt;a href=&quot;https://github.com/ddmee/git-hooks/blob/master/setup_repo.sh&quot;&gt;setup_repo.sh&lt;/a&gt; They can do that with this command&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config &lt;span class=&quot;nt&quot;&gt;--local&lt;/span&gt; include.path &lt;span class=&quot;s1&quot;&gt;'../.gitconfig'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is an essential detail, if you want the distributed client-side hooks to run.&lt;/p&gt;

&lt;h2 id=&quot;running-something-that-changes-the-commit-message&quot;&gt;Running something that changes the commit message&lt;/h2&gt;

&lt;p&gt;Now you need to write a hook inside the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git_hooks&lt;/code&gt; directory. I am going to write a hook that runs just before the user is asked to input a commit message. The hook is just a bash shell (though it does not have .sh as the filename suffix). If the shell exists with 0, the commit is allowed. Any other exit code blocks the commit. That’s how git hooks work.&lt;/p&gt;

&lt;p&gt;In your git repo, inside ‘git_hooks/’, create a ‘prepare-commit-msg’ file with the contents&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Providing an environment variable override is helpful, if users need to by-pass your hook for some reason.
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Set SKIP_HOOK environment variable if you don't want pre-commit tests.
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Example:
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# &amp;gt; $env:SKIP_HOOK=1
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# &amp;gt; git commit
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# &amp;gt; $env:SKIP_HOOK=0
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# The next 3 parameters are the parameters git supplies to the prepare-commit-msg hook. Different hooks get
&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# different parameters.
&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;COMMIT_MSG_FILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;COMMIT_SOURCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SHA1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$3&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$SKIP_HOOK&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Warning: SKIP_HOOK set, skipping pre-commit hook!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;0
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Run tests when this file changes.
&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SCRIPTPATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dirname&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-P&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Running pre-commit tests Pester tests are passing at &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$SCRIPTPATH&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Check Pester tests are passing.
&lt;/span&gt;
.&lt;span class=&quot;se&quot;&gt;\r&lt;/span&gt;un_tests.sh
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ERROR: detected test failures. Please fix before commiting changes.&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;1
&lt;span class=&quot;k&quot;&gt;fi
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Pre-commits tests have passed, continuing with commit.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[Pre-commit tests ran at &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$COMMIT_MSG_FILE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;outcome&quot;&gt;Outcome&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;If the tests pass, the user will be offered a default commit message that includes the ‘Pre-commit tests ran …’ message. You can see this in the commit &lt;a href=&quot;https://github.com/ddmee/git-hooks/commit/956d3fd00d9ba0fb9195796b7fc2aea402d848be&quot;&gt;956d3fd00d&lt;/a&gt; in the example repository.&lt;/li&gt;
  &lt;li&gt;If the tests fail, the commit is blocked with the error message.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ddmee/git-hooks/tree/master/git_hooks&quot;&gt;example-code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ddmee/git-hooks/blob/master/setup_repo.sh&quot;&gt;setup_repo.sh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ddmee/git-hooks/commit/956d3fd00d9ba0fb9195796b7fc2aea402d848be&quot;&gt;956d3fd00d&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks&quot;&gt;Git-SCM-Book-Git-Hooks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.tygertec.com/git-hooks-practical-uses-windows/&quot;&gt;git-hooks-practical-users&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/39338979&quot;&gt;stackoverflow-core-hookspath&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18329621/how-to-store-a-git-config-as-part-of-the-repository&quot;&gt;stackoverflow-store-gitconfig&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">How to run a test before every git commit Summary: Configure a git client-side prepare-commit-msg hook to run a test before every commit. Setup .gitconfig file in the root of the repository and set hooksPath = git_hooks. Write a bash script inside git_hooks\prepare-commit-msg that runs your tests before a commit. You can distribute the hooks in the repository but you cannot enforce the (client-side) hooks use. example-code is available. Running a Git client-side pre-commit hook Git hooks allow you to hook into the pull/commit/push process that git is built around. A hook is useful if you want to extend or customise the behaviour of your repository. There are two types of hooks, server-side commits and client-side commits. Server-side hooks live on a git server (i.e. somewhere people push to, like a centralised github server). Client-side hooks live on each individual contributors development machine. Server-side hooks are a way you can enforce certain behaviours on the server. I’m not going to talk about them here. Instead, I’m going to look at client-side hooks. Have you ever wanted to run some sort of check on the code you are about to commit? You can do this with a client-side hook. However, one issue with client-side hooks is that they are not versioned in the git repository. I used to think this prohibited ‘distrbution’ of the client-side git hooks with the repository. Which sucks. Because, lets say you introduce a new developer to your repo, perhaps you’d like them to run the same checks as you do, they way you do. Traditionally, that’s not been possible with client-side hooks. However, there is a way (since git version 2.9). You need to configure the ‘hooksPath’. Setting up client-side hooks so everyone runs them In the root of your git repo, add the file .gitconfig with this content: [core] hooksPath = git_hooks When the repository is cloned, it points git to run hooks from the git_hooks subdirectory. Normally, git hooks are stored in .git/hooks, and that .git/ directory is not stored in the version-control (thus prohibiting distribution with the source-code). But with the (new as of git 2.9) hooksPath option, you can instead point to another directory in the repository that does store the hooks. However, git will not use the .gitconfig automatically. Apparently it’s a security issue (see stackoverflow-store-gitconfig). Instead, the user who has cloned the repository must explicitly tell git to use the .gitconfig. They only need to run this command once. I have it as a setup_repo.sh They can do that with this command git config --local include.path '../.gitconfig' This is an essential detail, if you want the distributed client-side hooks to run. Running something that changes the commit message Now you need to write a hook inside the git_hooks directory. I am going to write a hook that runs just before the user is asked to input a commit message. The hook is just a bash shell (though it does not have .sh as the filename suffix). If the shell exists with 0, the commit is allowed. Any other exit code blocks the commit. That’s how git hooks work. In your git repo, inside ‘git_hooks/’, create a ‘prepare-commit-msg’ file with the contents #!/bin/sh # Providing an environment variable override is helpful, if users need to by-pass your hook for some reason. # Set SKIP_HOOK environment variable if you don't want pre-commit tests. # Example: # &amp;gt; $env:SKIP_HOOK=1 # &amp;gt; git commit # &amp;gt; $env:SKIP_HOOK=0 # The next 3 parameters are the parameters git supplies to the prepare-commit-msg hook. Different hooks get # different parameters. COMMIT_MSG_FILE=$1 COMMIT_SOURCE=$2 SHA1=$3 if [[ &quot;$SKIP_HOOK&quot; == 1 ]]; then printf &quot;\nWarning: SKIP_HOOK set, skipping pre-commit hook!\n&quot; exit 0 fi # Run tests when this file changes. SCRIPTPATH=&quot;$( cd &quot;$(dirname &quot;$0&quot;)&quot; ; pwd -P )&quot; printf &quot;\nRunning pre-commit tests Pester tests are passing at $SCRIPTPATH...\n&quot; # Check Pester tests are passing. .\run_tests.sh if [[ $? != 0 ]]; then printf &quot;\nERROR: detected test failures. Please fix before commiting changes.&quot; exit 1 fi printf &quot;\nPre-commits tests have passed, continuing with commit.\n&quot; echo &quot;[Pre-commit tests ran at $(date)]&quot; &amp;gt;&amp;gt; &quot;$COMMIT_MSG_FILE&quot; Outcome If the tests pass, the user will be offered a default commit message that includes the ‘Pre-commit tests ran …’ message. You can see this in the commit 956d3fd00d in the example repository. If the tests fail, the commit is blocked with the error message. References example-code setup_repo.sh 956d3fd00d Git-SCM-Book-Git-Hooks git-hooks-practical-users stackoverflow-core-hookspath stackoverflow-store-gitconfig</summary></entry></feed>